package frc.robot;


import frc.robot.commands.Autonomous.AutonomousCommand;
import frc.robot.commands.ClimberCommands.Climb;
import frc.robot.commands.ClimberCommands.ReleaseArm;
import frc.robot.commands.DriveCommands.DriveWithJoystick;
import frc.robot.commands.IntakeCommands.IntakeSpin;
import frc.robot.commands.IntakeCommands.IntakeStop;
import frc.robot.commands.IntakeCommands.LowerIntake;
import frc.robot.commands.LauncherCommands.LauncherTestBoth;
import frc.robot.commands.LauncherHoodCommands.HoodExtend;
import frc.robot.commands.LauncherHoodCommands.HoodRetract;
import frc.robot.commands.LauncherCommands.LauncherStop;
import frc.robot.commands.LauncherCommands.LauncherGo;
import frc.robot.subsystems.*;
import edu.wpi.first.wpilibj.smartdashboard.SendableChooser;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.CommandBase;


import edu.wpi.first.wpilibj2.command.Command;
import edu.wpi.first.wpilibj2.command.InstantCommand;
import edu.wpi.first.wpilibj2.command.SequentialCommandGroup;
import edu.wpi.first.wpilibj.XboxController;
//import edu.wpi.first.wpilibj.PS4Controller.Button;
import edu.wpi.first.wpilibj2.command.button.JoystickButton;
import edu.wpi.first.wpilibj.XboxController.Button;
import frc.robot.subsystems.*;
import edu.wpi.first.wpilibj.PneumaticsModuleType;
import frc.robot.subsystems.swerveDrivetrain;


/**
 * This class is where the bulk of the robot should be declared.  Since Command-based is a
 * "declarative" paradigm, very little robot logic should actually be handled in the {@link Robot}
 * periodic methods (other than the scheduler calls).  Instead, the structure of the robot
 * (including subsystems, commands, and button mappings) should be declared here.
 */
public class RobotContainer {

  private static RobotContainer m_robotContainer = new RobotContainer();

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
// The robot's subsystems
    //public final drivetrain m_drivetrain = new drivetrain()
    public final pneumatics m_pneumatics = new pneumatics();
    public final climber m_climber = new climber();
    public final launcher m_launcher = new launcher();
    public final intake m_intake = new intake();
    public final swerveDrivetrain m_swerveDrivetrain = new swerveDrivetrain();
    public final hopperA m_hopper = new hopperA();

  //public final swerveModules m_swerveModules = new swerveModules();
// Joysticks
private final XboxController xboxController0 = new XboxController(1);



  
  // A chooser for autonomous commands
  SendableChooser<Command> m_chooser = new SendableChooser<>();

  /**
  * The container for the robot.  Contains subsystems, OI devices, and commands.
  */
  private RobotContainer() {
     
    // Smartdashboard Subsystems


    // SmartDashboard Buttons
    SmartDashboard.putData("Autonomous Command", new AutonomousCommand());
    SmartDashboard.putData("SpinIntake", new IntakeSpin( m_intake, 0.5 ));
    SmartDashboard.putData("LaunchBall", new LauncherGo( m_launcher, 0.5 ));
    SmartDashboard.putData("Climb", new Climb( m_climber ));
    SmartDashboard.putData("ChangeHoodAngle", new HoodExtend( m_launcher ));
    SmartDashboard.putData("LowerIntake", new LowerIntake( m_intake ));
    SmartDashboard.putData("ReleaseArm", new ReleaseArm( m_climber ));
    SmartDashboard.putData("StopIntake", new IntakeStop( m_intake ));
    SmartDashboard.putData("LauncherStop", new LauncherStop( m_launcher));
    SmartDashboard.putData("SequentialCommandGroup", new SequentialCommandGroup());
    
        
    // Configure the button bindings
    configureButtonBindings();

    // Configure default commands

  //Used only for tuning turn off when complete!!

 //m_launcher.setDefaultCommand(new LauncherLeadTune(m_launcher));
 
 m_swerveDrivetrain.setDefaultCommand(new DriveWithJoystick(m_swerveDrivetrain, xboxController0));
   

    // Configure autonomous sendable chooser
    

    m_chooser.setDefaultOption("Autonomous Command", new AutonomousCommand());

     

    SmartDashboard.putData("Auto Mode", m_chooser);
  }

  public static RobotContainer getInstance() {
    return m_robotContainer;
  }

  /**
   * Use this method to define your button->command mappings.  Buttons can be created by
   * instantiating a {@link GenericHID} or one of its subclasses ({@link
   * edu.wpi.first.wpilibj.Joystick} or {@link XboxController}), and then passing it to a
   * {@link edu.wpi.first.wpilibj2.command.button.JoystickButton}.
   */
private void configureButtonBindings() {    
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=BUTTONS
// Create some buttons

new JoystickButton(xboxController0, Button.kRightBumper.value).whenPressed(new LauncherTestBoth(m_launcher,0.6, 0.1));
new JoystickButton(xboxController0, Button.kLeftBumper.value).whenPressed(new LauncherTestBoth(m_launcher, 0, 0));

new JoystickButton(xboxController0, Button.kA.value).whenPressed(new HoodExtend(m_launcher));
new JoystickButton(xboxController0, Button.kB.value).whenPressed(new HoodRetract(m_launcher));
/*
final JoystickButton intakeOnBtn = new JoystickButton(xboxController0, XboxController.Button.kX.value);        
intakeOnBtn.whenPressed(new IntakeSpin( m_intake, 0.5 ) ,true);
    SmartDashboard.putData("intakeOnBtn",new IntakeSpin( m_intake, 0.5 ) );

final JoystickButton launchBtn = new JoystickButton(xboxController0, XboxController.Button.kA.value);        
launchBtn.whenPressed(new LauncherGo( m_launcher, 0.5 ) ,true);
    SmartDashboard.putData("launchBtn",new LauncherGo( m_launcher, 0.5 ) );

final JoystickButton stopBtn = new JoystickButton(xboxController0, XboxController.Button.kB.value);        
stopBtn.whenPressed(new LauncherGo( m_launcher, 0.0) ,true);
    SmartDashboard.putData("stopBtn",new LauncherStop( m_launcher ) );
    

final JoystickButton climbRetractBtn = new JoystickButton(xboxController0, XboxController.Button.kY.value);        
climbRetractBtn.whenPressed(new Climb( m_climber ) ,true);
    SmartDashboard.putData("climbRetractBtn",new Climb( m_climber ) );

final JoystickButton HoodExtendBtn = new JoystickButton(xboxController0, XboxController.Button.kLeftBumper.value);        
HoodExtendBtn.whenPressed(new HoodExtend( m_launcher ) ,true);
    SmartDashboard.putData("HoodExtendBtn",new HoodExtend( m_launcher ) );

final JoystickButton HoodRetractBtn = new JoystickButton(xboxController0, XboxController.Button.kStart.value);        
HoodRetractBtn.whenPressed(new HoodExtend( m_launcher ) ,true);
        SmartDashboard.putData("HoodRetractBtn",new HoodExtend( m_launcher ) );

final JoystickButton lowerIntakeBtn = new JoystickButton(xboxController0, XboxController.Button.kRightBumper.value);        
lowerIntakeBtn.whenPressed(new LowerIntake( m_intake ) ,true);
    SmartDashboard.putData("lowerIntakeBtn",new LowerIntake( m_intake ) );

final JoystickButton armReleaser = new JoystickButton(xboxController0, XboxController.Button.kBack.value);        
armReleaser.whenPressed(new ReleaseArm( m_climber ) ,true);
    SmartDashboard.putData("armReleaser",new ReleaseArm( m_climber ) );

*/

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=BUTTONS
  }

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=FUNCTIONS
public XboxController getxboxController0() {
      return xboxController0;
    }


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=FUNCTIONS

  /**
   * Use this to pass the autonomous command to the main {@link Robot} class.
   *
   * @return the command to run in autonomous
  */
  public Command getAutonomousCommand() {
    // The selected command will be run in autonomous
    return m_chooser.getSelected();
  }
  

}

